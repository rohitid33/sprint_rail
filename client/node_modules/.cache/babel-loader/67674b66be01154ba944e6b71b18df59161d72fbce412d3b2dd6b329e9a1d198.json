{"ast":null,"code":"\"use client\";\n\n// src/HydrationBoundary.tsx\nimport * as React from \"react\";\nimport { hydrate } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nvar hasProperty = (obj, key) => {\n  return typeof obj === \"object\" && obj !== null && key in obj;\n};\nvar HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient\n}) => {\n  const client = useQueryClient(queryClient);\n  const [hydrationQueue, setHydrationQueue] = React.useState();\n  const optionsRef = React.useRef(options);\n  optionsRef.current = options;\n  React.useMemo(() => {\n    if (state) {\n      if (typeof state !== \"object\") {\n        return;\n      }\n      const queryCache = client.getQueryCache();\n      const queries = state.queries || [];\n      const newQueries = [];\n      const existingQueries = [];\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash);\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery);\n        } else {\n          const hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt ||\n          // RSC special serialized then-able chunks\n          hasProperty(dehydratedQuery.promise, \"status\") && hasProperty(existingQuery.promise, \"status\") && dehydratedQuery.promise.status !== existingQuery.promise.status;\n          const queryAlreadyQueued = hydrationQueue?.find(query => query.queryHash === dehydratedQuery.queryHash);\n          if (hydrationIsNewer && (!queryAlreadyQueued || dehydratedQuery.state.dataUpdatedAt > queryAlreadyQueued.state.dataUpdatedAt)) {\n            existingQueries.push(dehydratedQuery);\n          }\n        }\n      }\n      if (newQueries.length > 0) {\n        hydrate(client, {\n          queries: newQueries\n        }, optionsRef.current);\n      }\n      if (existingQueries.length > 0) {\n        setHydrationQueue(prev => prev ? [...prev, ...existingQueries] : existingQueries);\n      }\n    }\n  }, [client, hydrationQueue, state]);\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, {\n        queries: hydrationQueue\n      }, optionsRef.current);\n      setHydrationQueue(void 0);\n    }\n  }, [client, hydrationQueue]);\n  return children;\n};\nexport { HydrationBoundary };","map":{"version":3,"names":["React","hydrate","useQueryClient","hasProperty","obj","key","HydrationBoundary","children","options","state","queryClient","client","hydrationQueue","setHydrationQueue","useState","optionsRef","useRef","current","useMemo","queryCache","getQueryCache","queries","newQueries","existingQueries","dehydratedQuery","existingQuery","get","queryHash","push","hydrationIsNewer","dataUpdatedAt","promise","status","queryAlreadyQueued","find","query","length","prev","useEffect"],"sources":["C:\\Users\\msi\\Desktop\\sprint\\sprint_code\\client\\node_modules\\@tanstack\\react-query\\src\\HydrationBoundary.tsx"],"sourcesContent":["/* eslint-disable react-compiler/react-compiler */\n\n'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state?: unknown\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nconst hasProperty = <TKey extends string>(\n  obj: unknown,\n  key: TKey,\n): obj is { [k in TKey]: unknown } => {\n  return typeof obj === 'object' && obj !== null && key in obj\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n  const [hydrationQueue, setHydrationQueue] = React.useState<\n    DehydratedState['queries'] | undefined\n  >()\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // This useMemo is for performance reasons only, everything inside it _must_\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  React.useMemo(() => {\n    if (state) {\n      if (typeof state !== 'object') {\n        return\n      }\n\n      const queryCache = client.getQueryCache()\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      const queries = (state as DehydratedState).queries || []\n\n      const newQueries: DehydratedState['queries'] = []\n      const existingQueries: DehydratedState['queries'] = []\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery)\n        } else {\n          const hydrationIsNewer =\n            dehydratedQuery.state.dataUpdatedAt >\n              existingQuery.state.dataUpdatedAt || // RSC special serialized then-able chunks\n            (hasProperty(dehydratedQuery.promise, 'status') &&\n              hasProperty(existingQuery.promise, 'status') &&\n              dehydratedQuery.promise.status !== existingQuery.promise.status)\n\n          const queryAlreadyQueued = hydrationQueue?.find(\n            (query) => query.queryHash === dehydratedQuery.queryHash,\n          )\n\n          if (\n            hydrationIsNewer &&\n            (!queryAlreadyQueued ||\n              dehydratedQuery.state.dataUpdatedAt >\n                queryAlreadyQueued.state.dataUpdatedAt)\n          ) {\n            existingQueries.push(dehydratedQuery)\n          }\n        }\n      }\n\n      if (newQueries.length > 0) {\n        // It's actually fine to call this with queries/state that already exists\n        // in the cache, or is older. hydrate() is idempotent for queries.\n        hydrate(client, { queries: newQueries }, optionsRef.current)\n      }\n      if (existingQueries.length > 0) {\n        setHydrationQueue((prev) =>\n          prev ? [...prev, ...existingQueries] : existingQueries,\n        )\n      }\n    }\n  }, [client, hydrationQueue, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n      setHydrationQueue(undefined)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"],"mappings":";;;AAGA,YAAYA,KAAA,MAAW;AAEvB,SAASC,OAAA,QAAe;AACxB,SAASC,cAAA,QAAsB;AAoB/B,IAAMC,WAAA,GAAcA,CAClBC,GAAA,EACAC,GAAA,KACoC;EACpC,OAAO,OAAOD,GAAA,KAAQ,YAAYA,GAAA,KAAQ,QAAQC,GAAA,IAAOD,GAAA;AAC3D;AAEO,IAAME,iBAAA,GAAoBA,CAAC;EAChCC,QAAA;EACAC,OAAA,GAAU,CAAC;EACXC,KAAA;EACAC;AACF,MAA8B;EAC5B,MAAMC,MAAA,GAAST,cAAA,CAAeQ,WAAW;EACzC,MAAM,CAACE,cAAA,EAAgBC,iBAAiB,IAAUb,KAAA,CAAAc,QAAA,CAEhD;EAEF,MAAMC,UAAA,GAAmBf,KAAA,CAAAgB,MAAA,CAAOR,OAAO;EACvCO,UAAA,CAAWE,OAAA,GAAUT,OAAA;EAiBfR,KAAA,CAAAkB,OAAA,CAAQ,MAAM;IAClB,IAAIT,KAAA,EAAO;MACT,IAAI,OAAOA,KAAA,KAAU,UAAU;QAC7B;MACF;MAEA,MAAMU,UAAA,GAAaR,MAAA,CAAOS,aAAA,CAAc;MAExC,MAAMC,OAAA,GAAWZ,KAAA,CAA0BY,OAAA,IAAW,EAAC;MAEvD,MAAMC,UAAA,GAAyC,EAAC;MAChD,MAAMC,eAAA,GAA8C,EAAC;MACrD,WAAWC,eAAA,IAAmBH,OAAA,EAAS;QACrC,MAAMI,aAAA,GAAgBN,UAAA,CAAWO,GAAA,CAAIF,eAAA,CAAgBG,SAAS;QAE9D,IAAI,CAACF,aAAA,EAAe;UAClBH,UAAA,CAAWM,IAAA,CAAKJ,eAAe;QACjC,OAAO;UACL,MAAMK,gBAAA,GACJL,eAAA,CAAgBf,KAAA,CAAMqB,aAAA,GACpBL,aAAA,CAAchB,KAAA,CAAMqB,aAAA;UAAA;UACrB3B,WAAA,CAAYqB,eAAA,CAAgBO,OAAA,EAAS,QAAQ,KAC5C5B,WAAA,CAAYsB,aAAA,CAAcM,OAAA,EAAS,QAAQ,KAC3CP,eAAA,CAAgBO,OAAA,CAAQC,MAAA,KAAWP,aAAA,CAAcM,OAAA,CAAQC,MAAA;UAE7D,MAAMC,kBAAA,GAAqBrB,cAAA,EAAgBsB,IAAA,CACxCC,KAAA,IAAUA,KAAA,CAAMR,SAAA,KAAcH,eAAA,CAAgBG,SACjD;UAEA,IACEE,gBAAA,KACC,CAACI,kBAAA,IACAT,eAAA,CAAgBf,KAAA,CAAMqB,aAAA,GACpBG,kBAAA,CAAmBxB,KAAA,CAAMqB,aAAA,GAC7B;YACAP,eAAA,CAAgBK,IAAA,CAAKJ,eAAe;UACtC;QACF;MACF;MAEA,IAAIF,UAAA,CAAWc,MAAA,GAAS,GAAG;QAGzBnC,OAAA,CAAQU,MAAA,EAAQ;UAAEU,OAAA,EAASC;QAAW,GAAGP,UAAA,CAAWE,OAAO;MAC7D;MACA,IAAIM,eAAA,CAAgBa,MAAA,GAAS,GAAG;QAC9BvB,iBAAA,CAAmBwB,IAAA,IACjBA,IAAA,GAAO,CAAC,GAAGA,IAAA,EAAM,GAAGd,eAAe,IAAIA,eACzC;MACF;IACF;EACF,GAAG,CAACZ,MAAA,EAAQC,cAAA,EAAgBH,KAAK,CAAC;EAE5BT,KAAA,CAAAsC,SAAA,CAAU,MAAM;IACpB,IAAI1B,cAAA,EAAgB;MAClBX,OAAA,CAAQU,MAAA,EAAQ;QAAEU,OAAA,EAAST;MAAe,GAAGG,UAAA,CAAWE,OAAO;MAC/DJ,iBAAA,CAAkB,MAAS;IAC7B;EACF,GAAG,CAACF,MAAA,EAAQC,cAAc,CAAC;EAE3B,OAAOL,QAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}